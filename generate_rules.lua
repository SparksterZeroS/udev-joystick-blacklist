--- @type integer
EXIT_FAILURE = 1

--- @type integer
EXIT_SUCCESS = 0

--- @type string
DIST_DIR = "dist"

--- @type string
JOYSTICK_BLACKLIST_REMOVE_PERMISSION_FILENAME = "91-joystick-blacklist.rules"

--- @type string
JOYSTICK_BLACKLIST_REMOVE_DEVICE_FILENAME = "91-joystick-blacklist-rm.rules"

--- @type string
JOYSTICK_BLACKLIST_REMOVE_PERMISSION_PATH = DIST_DIR .. '/' .. JOYSTICK_BLACKLIST_REMOVE_PERMISSION_FILENAME

--- @type string
JOYSTICK_BLACKLIST_REMOVE_DEVICE_PATH = DIST_DIR .. '/' .. JOYSTICK_BLACKLIST_REMOVE_DEVICE_FILENAME

--- @type string
JOYSTICK_BLACKLIST_REMOVE_PERMISSION_HEADER_DISCLAIMER = string.format([[
# /etc/udev/rules.d/%s
# sudo cp ./%s/%s /etc/udev/rules.d/%s
#
# This file is automatically generated by a script.
# For more information, please see https://git.anthonyijacksonjr.xyz/anthonyjacksonjr/udev-joystick-blacklist.

]], JOYSTICK_BLACKLIST_REMOVE_PERMISSION_FILENAME, DIST_DIR, JOYSTICK_BLACKLIST_REMOVE_PERMISSION_FILENAME,
    JOYSTICK_BLACKLIST_REMOVE_PERMISSION_FILENAME)

--- @type string
JOYSTICK_BLACKLIST_REMOVE_DEVICE_HEADER_DISCLAIMER = string.format([[
# /etc/udev/rules.d/%s
# sudo cp ./%s/%s /etc/udev/rules.d/%s
#
# This file is automatically generated by a script.
# For more information, please see https://git.anthonyijacksonjr.xyz/anthonyjacksonjr/udev-joystick-blacklist.

]], JOYSTICK_BLACKLIST_REMOVE_DEVICE_FILENAME, DIST_DIR, JOYSTICK_BLACKLIST_REMOVE_DEVICE_FILENAME,
    JOYSTICK_BLACKLIST_REMOVE_DEVICE_FILENAME)

--- @type integer
ID_STRING_LENGTH = 4

--- @type string
JOYSTICK_BLACKLIST_REMOVE_PERMISSION_TEMPLATE = [[
SUBSYSTEM=="input", ATTRS{idVendor}=="%s", ATTRS{idProduct}=="%s", ENV{ID_INPUT_JOYSTICK}=="?*", ENV{ID_INPUT_JOYSTICK}=""
SUBSYSTEM=="input", ATTRS{idVendor}=="%s", ATTRS{idProduct}=="%s", KERNEL=="js[0-9]*", MODE="0000", ENV{ID_INPUT_JOYSTICK}=""
]]

--- @type string
JOYSTICK_BLACKLIST_REMOVE_DEVICE_TEMPLATE = [[
SUBSYSTEM=="input", ATTRS{idVendor}=="%s", ATTRS{idProduct}=="%s", ENV{ID_INPUT_JOYSTICK}=="?*", ENV{ID_INPUT_JOYSTICK}=""
SUBSYSTEM=="input", ATTRS{idVendor}=="%s", ATTRS{idProduct}=="%s", KERNEL=="js[0-9]*", RUN+="/bin/rm %%E{DEVNAME}", ENV{ID_INPUT_JOYSTICK}=""
]]

---comment
---@param id_pair string
---@return string | nil
local function strip_device_id_pair(id_pair)
    local stripped_id_pair = string.gsub(id_pair, " ", "")

    if stripped_id_pair:len() == 0 then
        return nil
    end

    if stripped_id_pair:sub(1, 1) == '#' then
        return nil
    end

    local comment_start_index = stripped_id_pair:find('#')
    if comment_start_index == nil then
        return stripped_id_pair
    end

    return stripped_id_pair:sub(1, comment_start_index - 1)
end


--- Reads the device list and parses the values.
--- @return string[] | nil
local function load_device_id_pair_list()
    local file = io.open("devices", "r")
    if file == nil then
        io.stderr:write(
            "The device list file is missing.\nPlease ensure the script is running in the same directory of the device list.\n")
        return nil
    end

    local device_ids = {}

    --- @type string
    for line in file:lines() do
        local stripped_device_id_pair = strip_device_id_pair(line)
        if stripped_device_id_pair ~= nil then
            table.insert(device_ids, stripped_device_id_pair)
        end
    end

    file:close()
    return device_ids
end

---Seperate the vender and product id from a device id pair.
---@param pair string
---@return string[] | nil separated_pair
local function separate_device_id_pair(pair)
    if type(pair) ~= "string" then
        return nil
    end

    local pair_seperation_index = string.find(pair, ',')
    if pair_seperation_index == nil then
        return nil
    end

    local vender_id = string.sub(pair, 1, pair_seperation_index - 1)
    if vender_id:len() ~= ID_STRING_LENGTH then
        io.stdout:write(string.format("A vendor id is expected to be %d characters long.", ID_STRING_LENGTH))
    end

    local product_id = string.sub(pair, pair_seperation_index + 1)
    if product_id:len() ~= ID_STRING_LENGTH then
        io.stdout:write(string.format("A product id is expected to be %d characters long.", ID_STRING_LENGTH))
    end

    return { vender_id, product_id }
end

--- Creates the udev rules blacklist file.
---@param path string
---@param device_id_list string[]
---@return boolean success
local function create_udev_rules_file(path, device_id_list, remove_dev)
    local file = io.open(path, "w")
    if file == nil then
        return false
    end

    if remove_dev then
        file:write(JOYSTICK_BLACKLIST_REMOVE_PERMISSION_HEADER_DISCLAIMER)
    else
        file:write(JOYSTICK_BLACKLIST_REMOVE_DEVICE_HEADER_DISCLAIMER)
    end

    for pair_index in ipairs(device_id_list) do
        ---@type string
        local pair = device_id_list[pair_index]
        local seperated_pair = separate_device_id_pair(pair)
        if seperated_pair == nil then
            io.stdout:write(string.format("Illegal device id pair. \"%s\"", pair))
            return false
        end

        local udev_rule_entry = ""

        if not remove_dev then
            udev_rule_entry = string.format(JOYSTICK_BLACKLIST_REMOVE_PERMISSION_TEMPLATE,
                seperated_pair[1],
                seperated_pair[2],
                seperated_pair[1],
                seperated_pair[2]
            )
        else
            udev_rule_entry = string.format(JOYSTICK_BLACKLIST_REMOVE_DEVICE_TEMPLATE,
                seperated_pair[1],
                seperated_pair[2],
                seperated_pair[1],
                seperated_pair[2]
            )
        end
        file:write(udev_rule_entry)
    end

    file:close()

    return true
end

--- @return integer
local function main()
    local device_id_pair_list = load_device_id_pair_list()
    if device_id_pair_list == nil then
        return EXIT_FAILURE
    end

    os.execute("mkdir " .. DIST_DIR)
    create_udev_rules_file(JOYSTICK_BLACKLIST_REMOVE_PERMISSION_PATH, device_id_pair_list, false)
    create_udev_rules_file(JOYSTICK_BLACKLIST_REMOVE_DEVICE_PATH, device_id_pair_list, true)

    return EXIT_SUCCESS
end

os.exit(main())
